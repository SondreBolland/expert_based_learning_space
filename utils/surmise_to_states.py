from itertools import chain, combinations
from typing import Set, List

from model.surmise_function import SurmiseFunction

def powerset(items: Set[str]):
    "Returns all subsets of the set of items"
    return list(map(set, chain.from_iterable(combinations(items, r) for r in range(len(items) + 1))))

def surmise_to_states(sf: SurmiseFunction) -> List[frozenset]:
    """
    Computes the knowledge states generated by the surmise function.
    A state is valid if for every item in the state, one of its clauses is satisfied.

    Returns:
        A list of frozensets, each representing a valid knowledge state, sorted by size.
    """
    # All items mentioned in the surmise function
    items = set(sf.surmise.keys())
    for clauses in sf.surmise.values():
        for clause in clauses:
            items.update(clause.prerequisites)

    all_subsets = powerset(items)
    knowledge_states = set()

    for subset in all_subsets:
        valid = True
        for item in subset:
            clauses = sf.get_clauses(item)
            if not clauses:
                continue  # If no clauses, assume always learnable
            if not any(clause.is_satisfied_by(subset) for clause in clauses):
                valid = False
                break
        if valid:
            knowledge_states.add(frozenset(subset))

    # Sort knowledge states by size, then lexicographically
    return sorted(knowledge_states, key=lambda s: (len(s), sorted(s)))
